import { Workbox } from 'workbox-window';\n\ninterface PWAInstallPrompt {\n  prompt(): Promise<void>;\n  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;\n}\n\nexport interface PWACapabilities {\n  canInstall: boolean;\n  isInstalled: boolean;\n  isOnline: boolean;\n  hasNotificationSupport: boolean;\n  hasBackgroundSync: boolean;\n  hasPushMessaging: boolean;\n}\n\nclass PWAService {\n  private workbox: Workbox | null = null;\n  private installPrompt: PWAInstallPrompt | null = null;\n  private listeners: Map<string, Set<Function>> = new Map();\n  private capabilities: PWACapabilities = {\n    canInstall: false,\n    isInstalled: false,\n    isOnline: navigator.onLine,\n    hasNotificationSupport: 'Notification' in window,\n    hasBackgroundSync: 'serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype,\n    hasPushMessaging: 'serviceWorker' in navigator && 'PushManager' in window,\n  };\n\n  constructor() {\n    this.init();\n  }\n\n  private async init() {\n    // Check if app is already installed\n    if (window.matchMedia('(display-mode: standalone)').matches || \n        (window.navigator as any).standalone === true) {\n      this.capabilities.isInstalled = true;\n    }\n\n    // Listen for install prompt\n    window.addEventListener('beforeinstallprompt', (e) => {\n      e.preventDefault();\n      this.installPrompt = e as any;\n      this.capabilities.canInstall = true;\n      this.emit('installable', true);\n    });\n\n    // Listen for app installed\n    window.addEventListener('appinstalled', () => {\n      this.capabilities.isInstalled = true;\n      this.capabilities.canInstall = false;\n      this.installPrompt = null;\n      this.emit('installed', true);\n    });\n\n    // Listen for online/offline changes\n    window.addEventListener('online', () => {\n      this.capabilities.isOnline = true;\n      this.emit('online', true);\n    });\n\n    window.addEventListener('offline', () => {\n      this.capabilities.isOnline = false;\n      this.emit('online', false);\n    });\n\n    // Initialize service worker\n    if ('serviceWorker' in navigator) {\n      this.initServiceWorker();\n    }\n  }\n\n  private async initServiceWorker() {\n    try {\n      this.workbox = new Workbox('/sw.js');\n\n      // Listen for waiting service worker\n      this.workbox.addEventListener('waiting', (event) => {\n        this.emit('updateAvailable', {\n          skipWaiting: () => {\n            if (this.workbox) {\n              this.workbox.addEventListener('controlling', () => {\n                window.location.reload();\n              });\n              this.workbox.messageSkipWaiting();\n            }\n          }\n        });\n      });\n\n      // Listen for service worker updates\n      this.workbox.addEventListener('installed', (event) => {\n        if (event.isUpdate) {\n          this.emit('updated', event);\n        } else {\n          this.emit('installed', event);\n        }\n      });\n\n      // Listen for service worker messages\n      this.workbox.addEventListener('message', (event) => {\n        this.emit('message', event.data);\n      });\n\n      // Register service worker\n      await this.workbox.register();\n      \n    } catch (error) {\n      console.error('Service worker registration failed:', error);\n    }\n  }\n\n  // Install the PWA\n  async install(): Promise<boolean> {\n    if (!this.installPrompt) {\n      throw new Error('Install prompt not available');\n    }\n\n    try {\n      await this.installPrompt.prompt();\n      const choiceResult = await this.installPrompt.userChoice;\n      \n      if (choiceResult.outcome === 'accepted') {\n        this.installPrompt = null;\n        this.capabilities.canInstall = false;\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Installation failed:', error);\n      return false;\n    }\n  }\n\n  // Request notification permission\n  async requestNotificationPermission(): Promise<NotificationPermission> {\n    if (!this.capabilities.hasNotificationSupission) {\n      throw new Error('Notifications not supported');\n    }\n\n    const permission = await Notification.requestPermission();\n    this.emit('notificationPermission', permission);\n    return permission;\n  }\n\n  // Show local notification\n  async showNotification(title: string, options?: NotificationOptions): Promise<void> {\n    if (!this.capabilities.hasNotificationSupport) {\n      throw new Error('Notifications not supported');\n    }\n\n    if (Notification.permission !== 'granted') {\n      const permission = await this.requestNotificationPermission();\n      if (permission !== 'granted') {\n        throw new Error('Notification permission denied');\n      }\n    }\n\n    // Show notification through service worker if available\n    if (this.workbox && 'serviceWorker' in navigator && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage({\n        type: 'SHOW_NOTIFICATION',\n        payload: { title, options }\n      });\n    } else {\n      // Fallback to regular notification\n      new Notification(title, options);\n    }\n  }\n\n  // Register for push notifications\n  async subscribeToPush(vapidKey: string): Promise<PushSubscription | null> {\n    if (!this.capabilities.hasPushMessaging) {\n      throw new Error('Push messaging not supported');\n    }\n\n    try {\n      const registration = await navigator.serviceWorker.getRegistration();\n      if (!registration) {\n        throw new Error('Service worker not registered');\n      }\n\n      const subscription = await registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: this.urlBase64ToUint8Array(vapidKey)\n      });\n\n      this.emit('pushSubscribed', subscription);\n      return subscription;\n    } catch (error) {\n      console.error('Push subscription failed:', error);\n      return null;\n    }\n  }\n\n  // Background sync\n  async scheduleBackgroundSync(tag: string, data?: any): Promise<void> {\n    if (!this.capabilities.hasBackgroundSync) {\n      throw new Error('Background sync not supported');\n    }\n\n    try {\n      const registration = await navigator.serviceWorker.getRegistration();\n      if (!registration) {\n        throw new Error('Service worker not registered');\n      }\n\n      // Store data for sync\n      if (data) {\n        await this.storeDataForSync(tag, data);\n      }\n\n      // Register sync\n      await (registration as any).sync.register(tag);\n      this.emit('syncScheduled', { tag, data });\n    } catch (error) {\n      console.error('Background sync scheduling failed:', error);\n      throw error;\n    }\n  }\n\n  // Store data in IndexedDB for sync\n  private async storeDataForSync(tag: string, data: any): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('pwa-sync-data', 1);\n      \n      request.onerror = () => reject(request.error);\n      \n      request.onupgradeneeded = () => {\n        const db = request.result;\n        if (!db.objectStoreNames.contains('syncData')) {\n          db.createObjectStore('syncData');\n        }\n      };\n      \n      request.onsuccess = () => {\n        const db = request.result;\n        const transaction = db.transaction(['syncData'], 'readwrite');\n        const store = transaction.objectStore('syncData');\n        \n        store.put({\n          data,\n          timestamp: Date.now()\n        }, tag);\n        \n        transaction.oncomplete = () => resolve();\n        transaction.onerror = () => reject(transaction.error);\n      };\n    });\n  }\n\n  // Get stored sync data\n  async getSyncData(tag: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('pwa-sync-data', 1);\n      \n      request.onerror = () => reject(request.error);\n      \n      request.onsuccess = () => {\n        const db = request.result;\n        const transaction = db.transaction(['syncData'], 'readonly');\n        const store = transaction.objectStore('syncData');\n        const getRequest = store.get(tag);\n        \n        getRequest.onsuccess = () => {\n          resolve(getRequest.result?.data);\n        };\n        \n        getRequest.onerror = () => reject(getRequest.error);\n      };\n    });\n  }\n\n  // Clear sync data\n  async clearSyncData(tag: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('pwa-sync-data', 1);\n      \n      request.onerror = () => reject(request.error);\n      \n      request.onsuccess = () => {\n        const db = request.result;\n        const transaction = db.transaction(['syncData'], 'readwrite');\n        const store = transaction.objectStore('syncData');\n        \n        const deleteRequest = store.delete(tag);\n        \n        deleteRequest.onsuccess = () => resolve();\n        deleteRequest.onerror = () => reject(deleteRequest.error);\n      };\n    });\n  }\n\n  // Cache management\n  async clearCaches(): Promise<void> {\n    if ('caches' in window) {\n      const cacheNames = await caches.keys();\n      await Promise.all(\n        cacheNames.map(cacheName => caches.delete(cacheName))\n      );\n      this.emit('cachesCleared', true);\n    }\n  }\n\n  async getCacheSize(): Promise<number> {\n    if (!('caches' in window)) return 0;\n\n    let size = 0;\n    const cacheNames = await caches.keys();\n    \n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n      \n      for (const request of requests) {\n        const response = await cache.match(request);\n        if (response) {\n          const blob = await response.blob();\n          size += blob.size;\n        }\n      }\n    }\n    \n    return size;\n  }\n\n  // Event system\n  on(event: string, callback: Function): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    \n    this.listeners.get(event)!.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const eventListeners = this.listeners.get(event);\n      if (eventListeners) {\n        eventListeners.delete(callback);\n        if (eventListeners.size === 0) {\n          this.listeners.delete(event);\n        }\n      }\n    };\n  }\n\n  private emit(event: string, data: any): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(callback => callback(data));\n    }\n  }\n\n  // Get current capabilities\n  getCapabilities(): PWACapabilities {\n    return { ...this.capabilities };\n  }\n\n  // Utility function\n  private urlBase64ToUint8Array(base64String: string): Uint8Array {\n    const padding = '='.repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding)\n      .replace(/-/g, '+')\n      .replace(/_/g, '/');\n\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n  }\n\n  // Get network information\n  getNetworkInfo() {\n    const connection = (navigator as any).connection || \n                     (navigator as any).mozConnection || \n                     (navigator as any).webkitConnection;\n    \n    if (connection) {\n      return {\n        effectiveType: connection.effectiveType,\n        downlink: connection.downlink,\n        rtt: connection.rtt,\n        saveData: connection.saveData,\n      };\n    }\n    \n    return null;\n  }\n\n  // Check if running as PWA\n  isPWA(): boolean {\n    return this.capabilities.isInstalled;\n  }\n\n  // Check if online\n  isOnline(): boolean {\n    return this.capabilities.isOnline;\n  }\n}\n\nexport const pwaService = new PWAService();\n\n// React hook for PWA functionality\nexport const usePWA = () => {\n  return {\n    install: pwaService.install.bind(pwaService),\n    showNotification: pwaService.showNotification.bind(pwaService),\n    subscribeToPush: pwaService.subscribeToPush.bind(pwaService),\n    scheduleBackgroundSync: pwaService.scheduleBackgroundSync.bind(pwaService),\n    clearCaches: pwaService.clearCaches.bind(pwaService),\n    getCacheSize: pwaService.getCacheSize.bind(pwaService),\n    getCapabilities: pwaService.getCapabilities.bind(pwaService),\n    getNetworkInfo: pwaService.getNetworkInfo.bind(pwaService),\n    isPWA: pwaService.isPWA.bind(pwaService),\n    isOnline: pwaService.isOnline.bind(pwaService),\n    on: pwaService.on.bind(pwaService),\n  };\n};