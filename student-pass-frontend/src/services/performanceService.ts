import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: string;\n  rating: 'good' | 'needs-improvement' | 'poor';\n  timestamp: number;\n  id: string;\n}\n\nexport interface PerformanceReport {\n  metrics: PerformanceMetric[];\n  userAgent: string;\n  url: string;\n  timestamp: number;\n  sessionId: string;\n  userId?: string;\n}\n\nexport interface PerformanceBudget {\n  FCP: number; // First Contentful Paint (ms)\n  LCP: number; // Largest Contentful Paint (ms)\n  FID: number; // First Input Delay (ms)\n  CLS: number; // Cumulative Layout Shift\n  TTFB: number; // Time to First Byte (ms)\n  bundleSize: number; // Bundle size (KB)\n  imageSize: number; // Total image size (KB)\n}\n\nclass PerformanceService {\n  private metrics: PerformanceMetric[] = [];\n  private sessionId: string;\n  private listeners: Map<string, Set<Function>> = new Map();\n  private reportQueue: PerformanceReport[] = [];\n  private isOnline: boolean = navigator.onLine;\n  private budget: PerformanceBudget = {\n    FCP: 1800, // 1.8s\n    LCP: 2500, // 2.5s\n    FID: 100,  // 100ms\n    CLS: 0.1,  // 0.1\n    TTFB: 800, // 800ms\n    bundleSize: 200, // 200KB\n    imageSize: 500,  // 500KB\n  };\n\n  constructor() {\n    this.sessionId = this.generateSessionId();\n    this.init();\n  }\n\n  private init() {\n    // Listen for network changes\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.sendQueuedReports();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n    });\n\n    // Collect Core Web Vitals\n    this.collectCoreWebVitals();\n\n    // Monitor long tasks\n    this.observeLongTasks();\n\n    // Monitor resource loading\n    this.observeResourceTiming();\n\n    // Monitor navigation timing\n    this.observeNavigationTiming();\n\n    // Monitor memory usage\n    this.observeMemoryUsage();\n\n    // Send reports before page unload\n    window.addEventListener('beforeunload', () => {\n      this.sendReport();\n    });\n\n    // Send reports periodically\n    setInterval(() => {\n      this.sendReport();\n    }, 30000); // Every 30 seconds\n  }\n\n  private collectCoreWebVitals() {\n    // Cumulative Layout Shift\n    getCLS((metric) => {\n      this.addMetric({\n        name: 'CLS',\n        value: metric.value,\n        unit: '',\n        rating: this.getRating('CLS', metric.value),\n        timestamp: Date.now(),\n        id: metric.id,\n      });\n    });\n\n    // First Input Delay\n    getFID((metric) => {\n      this.addMetric({\n        name: 'FID',\n        value: metric.value,\n        unit: 'ms',\n        rating: this.getRating('FID', metric.value),\n        timestamp: Date.now(),\n        id: metric.id,\n      });\n    });\n\n    // First Contentful Paint\n    getFCP((metric) => {\n      this.addMetric({\n        name: 'FCP',\n        value: metric.value,\n        unit: 'ms',\n        rating: this.getRating('FCP', metric.value),\n        timestamp: Date.now(),\n        id: metric.id,\n      });\n    });\n\n    // Largest Contentful Paint\n    getLCP((metric) => {\n      this.addMetric({\n        name: 'LCP',\n        value: metric.value,\n        unit: 'ms',\n        rating: this.getRating('LCP', metric.value),\n        timestamp: Date.now(),\n        id: metric.id,\n      });\n    });\n\n    // Time to First Byte\n    getTTFB((metric) => {\n      this.addMetric({\n        name: 'TTFB',\n        value: metric.value,\n        unit: 'ms',\n        rating: this.getRating('TTFB', metric.value),\n        timestamp: Date.now(),\n        id: metric.id,\n      });\n    });\n  }\n\n  private observeLongTasks() {\n    if ('PerformanceObserver' in window) {\n      try {\n        const observer = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry: any) => {\n            if (entry.duration > 50) { // Tasks longer than 50ms\n              this.addMetric({\n                name: 'Long Task',\n                value: entry.duration,\n                unit: 'ms',\n                rating: entry.duration > 100 ? 'poor' : 'needs-improvement',\n                timestamp: Date.now(),\n                id: `longtask-${Date.now()}`,\n              });\n            }\n          });\n        });\n\n        observer.observe({ entryTypes: ['longtask'] });\n      } catch (error) {\n        console.warn('Long task observation not supported:', error);\n      }\n    }\n  }\n\n  private observeResourceTiming() {\n    if ('PerformanceObserver' in window) {\n      try {\n        const observer = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry: PerformanceResourceTiming) => {\n            const duration = entry.responseEnd - entry.requestStart;\n            \n            // Track slow resources\n            if (duration > 1000) { // Resources taking more than 1s\n              this.addMetric({\n                name: 'Slow Resource',\n                value: duration,\n                unit: 'ms',\n                rating: duration > 3000 ? 'poor' : 'needs-improvement',\n                timestamp: Date.now(),\n                id: `resource-${entry.name}-${Date.now()}`,\n              });\n            }\n\n            // Track resource sizes\n            if (entry.transferSize) {\n              this.addMetric({\n                name: 'Resource Size',\n                value: entry.transferSize,\n                unit: 'bytes',\n                rating: this.getResourceSizeRating(entry.transferSize, entry.name),\n                timestamp: Date.now(),\n                id: `size-${entry.name}-${Date.now()}`,\n              });\n            }\n          });\n        });\n\n        observer.observe({ entryTypes: ['resource'] });\n      } catch (error) {\n        console.warn('Resource timing observation not supported:', error);\n      }\n    }\n  }\n\n  private observeNavigationTiming() {\n    if ('PerformanceObserver' in window) {\n      try {\n        const observer = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry: PerformanceNavigationTiming) => {\n            // DNS lookup time\n            const dnsTime = entry.domainLookupEnd - entry.domainLookupStart;\n            this.addMetric({\n              name: 'DNS Lookup',\n              value: dnsTime,\n              unit: 'ms',\n              rating: dnsTime > 100 ? 'poor' : dnsTime > 50 ? 'needs-improvement' : 'good',\n              timestamp: Date.now(),\n              id: `dns-${Date.now()}`,\n            });\n\n            // Connection time\n            const connectTime = entry.connectEnd - entry.connectStart;\n            this.addMetric({\n              name: 'Connection',\n              value: connectTime,\n              unit: 'ms',\n              rating: connectTime > 200 ? 'poor' : connectTime > 100 ? 'needs-improvement' : 'good',\n              timestamp: Date.now(),\n              id: `connect-${Date.now()}`,\n            });\n\n            // DOM Content Loaded\n            const domContentLoaded = entry.domContentLoadedEventEnd - entry.navigationStart;\n            this.addMetric({\n              name: 'DOM Content Loaded',\n              value: domContentLoaded,\n              unit: 'ms',\n              rating: domContentLoaded > 2000 ? 'poor' : domContentLoaded > 1000 ? 'needs-improvement' : 'good',\n              timestamp: Date.now(),\n              id: `dcl-${Date.now()}`,\n            });\n\n            // Page Load\n            const pageLoad = entry.loadEventEnd - entry.navigationStart;\n            this.addMetric({\n              name: 'Page Load',\n              value: pageLoad,\n              unit: 'ms',\n              rating: pageLoad > 3000 ? 'poor' : pageLoad > 1500 ? 'needs-improvement' : 'good',\n              timestamp: Date.now(),\n              id: `load-${Date.now()}`,\n            });\n          });\n        });\n\n        observer.observe({ entryTypes: ['navigation'] });\n      } catch (error) {\n        console.warn('Navigation timing observation not supported:', error);\n      }\n    }\n  }\n\n  private observeMemoryUsage() {\n    // Check for memory API support\n    if ('memory' in performance) {\n      const checkMemory = () => {\n        const memInfo = (performance as any).memory;\n        \n        this.addMetric({\n          name: 'JS Heap Used',\n          value: memInfo.usedJSHeapSize,\n          unit: 'bytes',\n          rating: this.getMemoryRating(memInfo.usedJSHeapSize, memInfo.jsHeapSizeLimit),\n          timestamp: Date.now(),\n          id: `memory-${Date.now()}`,\n        });\n      };\n\n      // Check memory usage every 10 seconds\n      setInterval(checkMemory, 10000);\n    }\n  }\n\n  private getRating(metric: string, value: number): 'good' | 'needs-improvement' | 'poor' {\n    const thresholds: Record<string, [number, number]> = {\n      FCP: [1800, 3000],\n      LCP: [2500, 4000],\n      FID: [100, 300],\n      CLS: [0.1, 0.25],\n      TTFB: [800, 1800],\n    };\n\n    const [good, poor] = thresholds[metric] || [0, 0];\n    \n    if (value <= good) return 'good';\n    if (value <= poor) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getResourceSizeRating(size: number, name: string): 'good' | 'needs-improvement' | 'poor' {\n    const sizeKB = size / 1024;\n    \n    // Different thresholds for different resource types\n    if (name.match(/\\.(jpg|jpeg|png|gif|webp)$/i)) {\n      // Images\n      if (sizeKB <= 50) return 'good';\n      if (sizeKB <= 200) return 'needs-improvement';\n      return 'poor';\n    } else if (name.match(/\\.(js|css)$/i)) {\n      // Scripts and styles\n      if (sizeKB <= 50) return 'good';\n      if (sizeKB <= 150) return 'needs-improvement';\n      return 'poor';\n    }\n    \n    // Default thresholds\n    if (sizeKB <= 100) return 'good';\n    if (sizeKB <= 300) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private getMemoryRating(used: number, limit: number): 'good' | 'needs-improvement' | 'poor' {\n    const usage = used / limit;\n    \n    if (usage < 0.5) return 'good';\n    if (usage < 0.8) return 'needs-improvement';\n    return 'poor';\n  }\n\n  private addMetric(metric: PerformanceMetric) {\n    this.metrics.push(metric);\n    this.emit('metric', metric);\n\n    // Check budget violations\n    this.checkBudgetViolation(metric);\n\n    // Limit metrics array size\n    if (this.metrics.length > 100) {\n      this.metrics = this.metrics.slice(-50); // Keep last 50 metrics\n    }\n  }\n\n  private checkBudgetViolation(metric: PerformanceMetric) {\n    const budgetValue = this.budget[metric.name as keyof PerformanceBudget];\n    \n    if (budgetValue && metric.value > budgetValue) {\n      const violation = {\n        metric: metric.name,\n        value: metric.value,\n        budget: budgetValue,\n        severity: metric.rating,\n        timestamp: metric.timestamp,\n      };\n      \n      this.emit('budgetViolation', violation);\n    }\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private sendReport() {\n    if (this.metrics.length === 0) return;\n\n    const report: PerformanceReport = {\n      metrics: [...this.metrics],\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      timestamp: Date.now(),\n      sessionId: this.sessionId,\n    };\n\n    this.metrics = []; // Clear metrics after creating report\n\n    if (this.isOnline) {\n      this.sendReportToServer(report);\n    } else {\n      this.queueReport(report);\n    }\n  }\n\n  private async sendReportToServer(report: PerformanceReport) {\n    try {\n      await fetch('/api/performance/report', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(report),\n      });\n    } catch (error) {\n      console.warn('Failed to send performance report:', error);\n      this.queueReport(report);\n    }\n  }\n\n  private queueReport(report: PerformanceReport) {\n    this.reportQueue.push(report);\n    \n    // Limit queue size\n    if (this.reportQueue.length > 10) {\n      this.reportQueue = this.reportQueue.slice(-5); // Keep last 5 reports\n    }\n  }\n\n  private async sendQueuedReports() {\n    const reportsToSend = [...this.reportQueue];\n    this.reportQueue = [];\n\n    for (const report of reportsToSend) {\n      await this.sendReportToServer(report);\n    }\n  }\n\n  // Public API\n  measureUserTiming(name: string, startTime?: number): () => void {\n    const start = startTime || performance.now();\n    \n    return () => {\n      const duration = performance.now() - start;\n      \n      this.addMetric({\n        name: `User Timing: ${name}`,\n        value: duration,\n        unit: 'ms',\n        rating: duration > 1000 ? 'poor' : duration > 500 ? 'needs-improvement' : 'good',\n        timestamp: Date.now(),\n        id: `user-timing-${name}-${Date.now()}`,\n      });\n    };\n  }\n\n  markFeatureUsage(feature: string) {\n    this.addMetric({\n      name: `Feature Usage: ${feature}`,\n      value: 1,\n      unit: 'count',\n      rating: 'good',\n      timestamp: Date.now(),\n      id: `feature-${feature}-${Date.now()}`,\n    });\n  }\n\n  measureComponentRender(componentName: string): () => void {\n    const start = performance.now();\n    \n    return () => {\n      const duration = performance.now() - start;\n      \n      this.addMetric({\n        name: `Component Render: ${componentName}`,\n        value: duration,\n        unit: 'ms',\n        rating: duration > 50 ? 'poor' : duration > 16 ? 'needs-improvement' : 'good',\n        timestamp: Date.now(),\n        id: `component-${componentName}-${Date.now()}`,\n      });\n    };\n  }\n\n  getMetrics(): PerformanceMetric[] {\n    return [...this.metrics];\n  }\n\n  getBudget(): PerformanceBudget {\n    return { ...this.budget };\n  }\n\n  updateBudget(budget: Partial<PerformanceBudget>) {\n    this.budget = { ...this.budget, ...budget };\n    this.emit('budgetUpdated', this.budget);\n  }\n\n  getPerformanceSummary() {\n    const summary: Record<string, any> = {};\n    \n    // Group metrics by name\n    const groupedMetrics = this.metrics.reduce((acc, metric) => {\n      if (!acc[metric.name]) {\n        acc[metric.name] = [];\n      }\n      acc[metric.name].push(metric);\n      return acc;\n    }, {} as Record<string, PerformanceMetric[]>);\n\n    // Calculate statistics for each metric type\n    Object.entries(groupedMetrics).forEach(([name, metrics]) => {\n      const values = metrics.map(m => m.value);\n      const latest = metrics[metrics.length - 1];\n      \n      summary[name] = {\n        latest: latest.value,\n        average: values.reduce((a, b) => a + b, 0) / values.length,\n        min: Math.min(...values),\n        max: Math.max(...values),\n        count: values.length,\n        unit: latest.unit,\n        rating: latest.rating,\n      };\n    });\n\n    return summary;\n  }\n\n  // Event system\n  on(event: string, callback: Function): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    \n    this.listeners.get(event)!.add(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const eventListeners = this.listeners.get(event);\n      if (eventListeners) {\n        eventListeners.delete(callback);\n        if (eventListeners.size === 0) {\n          this.listeners.delete(event);\n        }\n      }\n    };\n  }\n\n  private emit(event: string, data: any): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(callback => callback(data));\n    }\n  }\n}\n\nexport const performanceService = new PerformanceService();\n\n// React hook for performance monitoring\nexport const usePerformance = () => {\n  return {\n    measureUserTiming: performanceService.measureUserTiming.bind(performanceService),\n    markFeatureUsage: performanceService.markFeatureUsage.bind(performanceService),\n    measureComponentRender: performanceService.measureComponentRender.bind(performanceService),\n    getMetrics: performanceService.getMetrics.bind(performanceService),\n    getBudget: performanceService.getBudget.bind(performanceService),\n    updateBudget: performanceService.updateBudget.bind(performanceService),\n    getPerformanceSummary: performanceService.getPerformanceSummary.bind(performanceService),\n    on: performanceService.on.bind(performanceService),\n  };\n};